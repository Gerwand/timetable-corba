// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.3

#include <OB/CORBAClient.h>
#include <GeneticTT.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030300L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace Genetic
{

::OB::TypeCodeConst _tc_LongSeq(
"017749f0150000004000000001ffffff1800000049444c3a47656e657469632f4c6f6e6753657"
"13a312e3000080000004c6f6e6753657100130000000c000000011e06df0300000000000000"
);

::OB::TypeCodeConst _tc_PeriodSeq(
"017749f0150000008c00000001ffffff1a00000049444c3a47656e657469632f506572696f645"
"365713a312e300000000a000000506572696f6453657100000013000000500000000100000015"
"00000040000000017f00001800000049444c3a47656e657469632f4c6f6e675365713a312e300"
"0080000004c6f6e6753657100130000000c000000018b0502030000000000000000000000"
);

::OB::TypeCodeConst _tc_IndividualSeq(
"017749f015000000e000000001ffffff1e00000049444c3a47656e657469632f496e646976696"
"475616c5365713a312e300000000e000000496e646976696475616c536571000000130000009c"
"00000001000000150000008c00000001444c3a1a00000049444c3a47656e657469632f5065726"
"96f645365713a312e300071000a000000506572696f6453657100000013000000500000000147"
"0402150000004000000001ffffff1800000049444c3a47656e657469632f4c6f6e675365713a3"
"12e3000080000004c6f6e6753657100130000000c0000000140a9f00300000000000000000000"
"0000000000"
);

::OB::TypeCodeConst _tc_Tuple(
"017749f00f0000007400000001ffffff1600000049444c3a47656e657469632f5475706c653a3"
"12e30005365060000005475706c6500000004000000080000007475706c654944000300000008"
"000000636c617373494400030000000a000000746561636865724944006e65030000000700000"
"0726f6f6d4944002e03000000"
);

::OB::TypeCodeConst _tc_TupleSeq(
"01cf71ef15000000c0000000010000001900000049444c3a47656e657469632f5475706c65536"
"5713a312e3000000000090000005475706c655365710000000013000000840000000140a9f00f"
"00000074000000017f00001600000049444c3a47656e657469632f5475706c653a312e3000a90"
"0060000005475706c6500000004000000080000007475706c654944000300000008000000636c"
"617373494400030000000a00000074656163686572494400f1f00300000007000000726f6f6d4"
"94400020300000000000000"
);

::OB::TypeCodeConst _tc_GeneticTimeTable(
"01cf71ef0e00000041000000010000002100000049444c3a47656e657469632f47656e6574696"
"354696d655461626c653a312e300075706c1100000047656e6574696354696d655461626c6500"
);

} // End of namespace Genetic

//
// IDL:Genetic/LongSeq:1.0
//
void
Genetic::OBInfo_LongSeq::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::Genetic::LongSeq& _ob_seq = *(const ::Genetic::LongSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    _ob_out -> write_long_array(_ob_seq.get_buffer(), _ob_len0);
}

void
Genetic::OBInfo_LongSeq::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::Genetic::LongSeq& _ob_seq = *(::Genetic::LongSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    _ob_in -> read_long_array(_ob_seq.get_buffer(), _ob_len0);
}

void
operator<<=(::CORBA::Any& any, Genetic::LongSeq* v)
{
    static const Genetic::OBInfo_LongSeq info;
    any.replace(Genetic::_tc_LongSeq, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const Genetic::LongSeq& v)
{
    any <<= new Genetic::LongSeq(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const Genetic::LongSeq*& v)
{
    if(any.check_type(Genetic::_tc_LongSeq))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            Genetic::LongSeq* val = new Genetic::LongSeq;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            _ob_in -> read_long_array((*val).get_buffer(), _ob_len0);
            (::CORBA::Any&)any <<= val;
        }

        v = (Genetic::LongSeq*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/PeriodSeq:1.0
//
void
Genetic::OBInfo_PeriodSeq::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::Genetic::PeriodSeq& _ob_seq = *(const ::Genetic::PeriodSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::Genetic::LongSeq const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_buf0[_ob_i0].length();
        _ob_out -> write_ulong(_ob_len1);
        _ob_out -> write_long_array(_ob_buf0[_ob_i0].get_buffer(), _ob_len1);
    }
}

void
Genetic::OBInfo_PeriodSeq::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::Genetic::PeriodSeq& _ob_seq = *(::Genetic::PeriodSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::Genetic::LongSeq * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
        _ob_buf0[_ob_i0].length(_ob_len1);
        _ob_in -> read_long_array(_ob_buf0[_ob_i0].get_buffer(), _ob_len1);
    }
}

void
operator<<=(::CORBA::Any& any, Genetic::PeriodSeq* v)
{
    static const Genetic::OBInfo_PeriodSeq info;
    any.replace(Genetic::_tc_PeriodSeq, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const Genetic::PeriodSeq& v)
{
    any <<= new Genetic::PeriodSeq(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const Genetic::PeriodSeq*& v)
{
    if(any.check_type(Genetic::_tc_PeriodSeq))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            Genetic::PeriodSeq* val = new Genetic::PeriodSeq;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::Genetic::LongSeq * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                _ob_buf0[_ob_i0].length(_ob_len1);
                _ob_in -> read_long_array(_ob_buf0[_ob_i0].get_buffer(), _ob_len1);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (Genetic::PeriodSeq*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/IndividualSeq:1.0
//
void
Genetic::OBInfo_IndividualSeq::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::Genetic::IndividualSeq& _ob_seq = *(const ::Genetic::IndividualSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::Genetic::PeriodSeq const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_buf0[_ob_i0].length();
        _ob_out -> write_ulong(_ob_len1);
        ::Genetic::LongSeq const * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
        {
            ::CORBA::ULong _ob_len2 = _ob_buf1[_ob_i1].length();
            _ob_out -> write_ulong(_ob_len2);
            _ob_out -> write_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
        }
    }
}

void
Genetic::OBInfo_IndividualSeq::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::Genetic::IndividualSeq& _ob_seq = *(::Genetic::IndividualSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::Genetic::PeriodSeq * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
        _ob_buf0[_ob_i0].length(_ob_len1);
        ::Genetic::LongSeq * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
        {
            ::CORBA::ULong _ob_len2 = _ob_in -> read_ulong();
            _ob_buf1[_ob_i1].length(_ob_len2);
            _ob_in -> read_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
        }
    }
}

void
operator<<=(::CORBA::Any& any, Genetic::IndividualSeq* v)
{
    static const Genetic::OBInfo_IndividualSeq info;
    any.replace(Genetic::_tc_IndividualSeq, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const Genetic::IndividualSeq& v)
{
    any <<= new Genetic::IndividualSeq(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const Genetic::IndividualSeq*& v)
{
    if(any.check_type(Genetic::_tc_IndividualSeq))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            Genetic::IndividualSeq* val = new Genetic::IndividualSeq;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::Genetic::PeriodSeq * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                _ob_buf0[_ob_i0].length(_ob_len1);
                ::Genetic::LongSeq * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                {
                    ::CORBA::ULong _ob_len2 = _ob_in -> read_ulong();
                    _ob_buf1[_ob_i1].length(_ob_len2);
                    _ob_in -> read_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
                }
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (Genetic::IndividualSeq*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/Tuple:1.0
//
void
Genetic::Tuple::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
    _ob_out -> write_long(tupleID);
    _ob_out -> write_long(classID);
    _ob_out -> write_long(teacherID);
    _ob_out -> write_long(roomID);
}

void
Genetic::Tuple::_OB_unmarshal(Tuple& _ob_v, OB::InputStreamImpl* _ob_in)
{
    _ob_v.tupleID = _ob_in -> read_long();
    _ob_v.classID = _ob_in -> read_long();
    _ob_v.teacherID = _ob_in -> read_long();
    _ob_v.roomID = _ob_in -> read_long();
}

void
operator<<=(::CORBA::Any& any, Genetic::Tuple* v)
{
    static const OB::Info< Genetic::Tuple > info;
    any.replace(Genetic::_tc_Tuple, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const Genetic::Tuple& v)
{
    any <<= new Genetic::Tuple(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const Genetic::Tuple*& v)
{
    if(any.check_type(Genetic::_tc_Tuple))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            Genetic::Tuple* val = new Genetic::Tuple;
            Genetic::Tuple::_OB_unmarshal(*val, _ob_in);
            (::CORBA::Any&)any <<= val;
        }

        v = (Genetic::Tuple*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/TupleSeq:1.0
//
void
Genetic::OBInfo_TupleSeq::marshal(const void* _ob_v, OB::OutputStreamImpl* _ob_out) const
{
    const ::Genetic::TupleSeq& _ob_seq = *(const ::Genetic::TupleSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_seq.length();
    _ob_out -> write_ulong(_ob_len0);
    ::Genetic::Tuple const * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
    }
}

void
Genetic::OBInfo_TupleSeq::unmarshal(void* _ob_v, OB::InputStreamImpl* _ob_in) const
{
    ::Genetic::TupleSeq& _ob_seq = *(::Genetic::TupleSeq*)_ob_v;
    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
    _ob_seq.length(_ob_len0);
    ::Genetic::Tuple * _ob_buf0 = _ob_seq.get_buffer();
    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::Genetic::Tuple::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
    }
}

void
operator<<=(::CORBA::Any& any, Genetic::TupleSeq* v)
{
    static const Genetic::OBInfo_TupleSeq info;
    any.replace(Genetic::_tc_TupleSeq, v, true, &info);
}

void
operator<<=(::CORBA::Any& any, const Genetic::TupleSeq& v)
{
    any <<= new Genetic::TupleSeq(v);
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, const Genetic::TupleSeq*& v)
{
    if(any.check_type(Genetic::_tc_TupleSeq))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            Genetic::TupleSeq* val = new Genetic::TupleSeq;
            ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
            (*val).length(_ob_len0);
            ::Genetic::Tuple * _ob_buf0 = (*val).get_buffer();
            for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
            {
                ::Genetic::Tuple::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
            }
            (::CORBA::Any&)any <<= val;
        }

        v = (Genetic::TupleSeq*)any.value();
        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/GeneticTimeTable:1.0
//
const char* Genetic::GeneticTimeTable::ids_[] =
{
    "IDL:Genetic/GeneticTimeTable:1.0",
    0
};

void
OBDuplicate(Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _add_ref();
}

void
OBRelease(Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _remove_ref();
}

Genetic::GeneticTimeTable_ptr
Genetic::GeneticTimeTable::_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        GeneticTimeTable_ptr v = 
            dynamic_cast< GeneticTimeTable_ptr >(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            OBProxy_Genetic::GeneticTimeTable* val = new OBProxy_Genetic::GeneticTimeTable;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

Genetic::GeneticTimeTable_ptr
Genetic::GeneticTimeTable::_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        GeneticTimeTable_ptr v =
            dynamic_cast< GeneticTimeTable_ptr >(p);
        if(v)
            return _duplicate(v);

        ::CORBA::Object_var obj = p -> _to_object();
        return _narrow(obj);
    }
    return _nil();
}

Genetic::GeneticTimeTable_ptr
Genetic::GeneticTimeTable::_unchecked_narrow(::CORBA::Object_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        GeneticTimeTable_ptr v =
            dynamic_cast< GeneticTimeTable_ptr >(p);
        if(v)
            return _duplicate(v);

        OBProxy_Genetic::GeneticTimeTable* val = new OBProxy_Genetic::GeneticTimeTable;
        val -> _OB_copyFrom(p);
        return val;
    }

    return _nil();
}

Genetic::GeneticTimeTable_ptr
Genetic::GeneticTimeTable::_unchecked_narrow(::CORBA::AbstractBase_ptr p)
{
    if(!::CORBA::is_nil(p))
    {
        ::CORBA::Object_var obj = p -> _to_object();
        return _unchecked_narrow(obj);
    }
    return _nil();
}

const char**
Genetic::GeneticTimeTable::_OB_staticIds()
{
    return ids_;
}

void
OBMarshal(Genetic::GeneticTimeTable_ptr _ob_v, OB::OutputStreamImpl* _ob_out)
{
    _ob_out -> write_Object(_ob_v);
}

void
OBUnmarshal(Genetic::GeneticTimeTable_ptr& _ob_v, OB::InputStreamImpl* _ob_in)
{
    Genetic::GeneticTimeTable_var old = _ob_v;
    ::CORBA::Object_var p = _ob_in -> read_Object();

    if(!::CORBA::is_nil(p))
    {
        OBProxy_Genetic::GeneticTimeTable* _ob_obj = new OBProxy_Genetic::GeneticTimeTable;
        _ob_obj -> _OB_copyFrom(p);
        _ob_v = _ob_obj;
    }
    else
        _ob_v = Genetic::GeneticTimeTable::_nil();
}

void
operator<<=(::CORBA::Any& any, Genetic::GeneticTimeTable_ptr* v)
{
    any.replace(Genetic::_tc_GeneticTimeTable, (::CORBA::Object_ptr)*v, true);
}

void
operator<<=(::CORBA::Any& any, Genetic::GeneticTimeTable_ptr v)
{
    Genetic::GeneticTimeTable_ptr val = Genetic::GeneticTimeTable::_duplicate(v);
    any <<= &val;
}

::CORBA::Boolean
operator>>=(const ::CORBA::Any& any, Genetic::GeneticTimeTable_ptr& v)
{
    if(any.check_type(Genetic::_tc_GeneticTimeTable))
    {
        ::CORBA::Object_ptr val = (::CORBA::Object_ptr)any.value();

        if(!::CORBA::is_nil(val))
        {
            if(!(v = dynamic_cast< Genetic::GeneticTimeTable_ptr >(val)))
            {
                OBProxy_Genetic::GeneticTimeTable* obj = new OBProxy_Genetic::GeneticTimeTable;
                obj -> _OB_copyFrom(val);
                v = obj;
                (::CORBA::Any&)any <<= &v;
            }
        }
        else
            v = Genetic::GeneticTimeTable::_nil();

        return true;
    }
    else
        return false;
}

//
// IDL:Genetic/GeneticTimeTable:1.0
//
OB::MarshalStubImpl_ptr
OBProxy_Genetic::GeneticTimeTable::_OB_createMarshalStubImpl()
{
    return new OBMarshalStubImpl_Genetic::GeneticTimeTable;
}

const char**
OBProxy_Genetic::GeneticTimeTable::_OB_ids() const
{
    return ::Genetic::GeneticTimeTable::ids_;
}

//
// IDL:Genetic/GeneticTimeTable/updateParameters:1.0
//
void
OBProxy_Genetic::GeneticTimeTable::updateParameters(::CORBA::Long _ob_a0,
                                                    ::CORBA::Long _ob_a1,
                                                    ::CORBA::Long _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> updateParameters(_ob_a0, _ob_a1, _ob_a2);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
//
::Genetic::IndividualSeq*
OBProxy_Genetic::GeneticTimeTable::getRandomPopulation(::CORBA::Long _ob_a0,
                                                       ::CORBA::Float_out _ob_a1)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> getRandomPopulation(_ob_a0, _ob_a1);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/mate:1.0
//
::Genetic::IndividualSeq*
OBProxy_Genetic::GeneticTimeTable::mate(::CORBA::Long _ob_a0,
                                        ::CORBA::Float_out _ob_a1,
                                        ::CORBA::Long_out _ob_a2)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> mate(_ob_a0, _ob_a1, _ob_a2);
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/tuples:1.0
//
::Genetic::TupleSeq*
OBProxy_Genetic::GeneticTimeTable::tuples()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> tuples();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

void
OBProxy_Genetic::GeneticTimeTable::tuples(const ::Genetic::TupleSeq& _ob_a)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl =
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> tuples(_ob_a);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/population:1.0
//
::Genetic::IndividualSeq*
OBProxy_Genetic::GeneticTimeTable::population()
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl = 
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            return _ob_stubImpl -> population();
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

void
OBProxy_Genetic::GeneticTimeTable::population(const ::Genetic::IndividualSeq& _ob_a)
{
    ::CORBA::ULong _ob_retry = 0, _ob_hop = 0;
    while(true)
    {
        try
        {
            OB::StubImplBase_var _ob_stubImplBase = _OB_getStubImpl();
            OBStubImpl_Genetic::GeneticTimeTable_ptr _ob_stubImpl =
                dynamic_cast< OBStubImpl_Genetic::GeneticTimeTable_ptr>(_ob_stubImplBase.in());
            _ob_stubImpl -> population(_ob_a);
            return;
        }
        catch(const OB::ExceptionBase& _ob_ex)
        {
            _OB_handleException(_ob_ex, _ob_retry, _ob_hop);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable:1.0
//
void
OBDuplicate(OBStubImpl_Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OBStubImpl_Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

//
// IDL:Genetic/GeneticTimeTable/updateParameters:1.0
//
void
OBMarshalStubImpl_Genetic::GeneticTimeTable::updateParameters(::CORBA::Long _ob_a0,
                                                              ::CORBA::Long _ob_a1,
                                                              ::CORBA::Long _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("updateParameters", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_long(_ob_a0);
                _ob_out -> write_long(_ob_a1);
                _ob_out -> write_long(_ob_a2);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
//
::Genetic::IndividualSeq*
OBMarshalStubImpl_Genetic::GeneticTimeTable::getRandomPopulation(::CORBA::Long _ob_a0,
                                                                 ::CORBA::Float_out _ob_a1)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("getRandomPopulation", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_long(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::Genetic::IndividualSeq_var _ob_r;
                try
                {
                    _ob_r = new ::Genetic::IndividualSeq;
                    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                    _ob_r -> length(_ob_len0);
                    ::Genetic::PeriodSeq * _ob_buf0 = _ob_r -> get_buffer();
                    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                    {
                        ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                        _ob_buf0[_ob_i0].length(_ob_len1);
                        ::Genetic::LongSeq * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                        {
                            ::CORBA::ULong _ob_len2 = _ob_in -> read_ulong();
                            _ob_buf1[_ob_i1].length(_ob_len2);
                            _ob_in -> read_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
                        }
                    }
                    _ob_a1 = _ob_in -> read_float();
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/mate:1.0
//
::Genetic::IndividualSeq*
OBMarshalStubImpl_Genetic::GeneticTimeTable::mate(::CORBA::Long _ob_a0,
                                                  ::CORBA::Float_out _ob_a1,
                                                  ::CORBA::Long_out _ob_a2)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("mate", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                _ob_out -> write_long(_ob_a0);
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            bool _ob_uex;
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down, _ob_uex);
            if(_ob_uex)
            {
                _OB_postUnmarshal(_ob_down);
            }
            else
            {
                ::Genetic::IndividualSeq_var _ob_r;
                try
                {
                    _ob_r = new ::Genetic::IndividualSeq;
                    ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                    _ob_r -> length(_ob_len0);
                    ::Genetic::PeriodSeq * _ob_buf0 = _ob_r -> get_buffer();
                    for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                    {
                        ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                        _ob_buf0[_ob_i0].length(_ob_len1);
                        ::Genetic::LongSeq * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                        for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                        {
                            ::CORBA::ULong _ob_len2 = _ob_in -> read_ulong();
                            _ob_buf1[_ob_i1].length(_ob_len2);
                            _ob_in -> read_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
                        }
                    }
                    _ob_a1 = _ob_in -> read_float();
                    _ob_a2 = _ob_in -> read_long();
                }
                catch(const ::CORBA::SystemException& _ob_ex)
                {
                    _OB_unmarshalEx(_ob_down, _ob_ex);
                }
                _OB_postUnmarshal(_ob_down);
                return _ob_r._retn();
            }
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/tuples:1.0
//
::Genetic::TupleSeq*
OBMarshalStubImpl_Genetic::GeneticTimeTable::tuples()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_get_tuples", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down);
            ::Genetic::TupleSeq_var _ob_r;
            try
            {
                _ob_r = new ::Genetic::TupleSeq;
                ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                _ob_r -> length(_ob_len0);
                ::Genetic::Tuple * _ob_buf0 = _ob_r -> get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    ::Genetic::Tuple::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_unmarshalEx(_ob_down, _ob_ex);
            }
            _OB_postUnmarshal(_ob_down);
            return _ob_r._retn();
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

void
OBMarshalStubImpl_Genetic::GeneticTimeTable::tuples(const ::Genetic::TupleSeq& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_set_tuples", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                ::CORBA::ULong _ob_len0 = _ob_a0.length();
                _ob_out -> write_ulong(_ob_len0);
                ::Genetic::Tuple const * _ob_buf0 = _ob_a0.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    _ob_buf0[_ob_i0]._OB_marshal(_ob_out);
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

//
// IDL:Genetic/GeneticTimeTable/population:1.0
//
::Genetic::IndividualSeq*
OBMarshalStubImpl_Genetic::GeneticTimeTable::population()
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_get_population", true);
        try
        {
            _OB_preMarshal(_ob_down);
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            OB::InputStreamImpl* _ob_in = _OB_preUnmarshal(_ob_down);
            ::Genetic::IndividualSeq_var _ob_r;
            try
            {
                _ob_r = new ::Genetic::IndividualSeq;
                ::CORBA::ULong _ob_len0 = _ob_in -> read_ulong();
                _ob_r -> length(_ob_len0);
                ::Genetic::PeriodSeq * _ob_buf0 = _ob_r -> get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    ::CORBA::ULong _ob_len1 = _ob_in -> read_ulong();
                    _ob_buf0[_ob_i0].length(_ob_len1);
                    ::Genetic::LongSeq * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                    for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                    {
                        ::CORBA::ULong _ob_len2 = _ob_in -> read_ulong();
                        _ob_buf1[_ob_i1].length(_ob_len2);
                        _ob_in -> read_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
                    }
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_unmarshalEx(_ob_down, _ob_ex);
            }
            _OB_postUnmarshal(_ob_down);
            return _ob_r._retn();
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

void
OBMarshalStubImpl_Genetic::GeneticTimeTable::population(const ::Genetic::IndividualSeq& _ob_a0)
{
    while(true)
    {
        OB::Downcall_var _ob_down = _OB_createDowncall("_set_population", true);
        try
        {
            OB::OutputStreamImpl* _ob_out = _OB_preMarshal(_ob_down);
            try
            {
                ::CORBA::ULong _ob_len0 = _ob_a0.length();
                _ob_out -> write_ulong(_ob_len0);
                ::Genetic::PeriodSeq const * _ob_buf0 = _ob_a0.get_buffer();
                for(::CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    ::CORBA::ULong _ob_len1 = _ob_buf0[_ob_i0].length();
                    _ob_out -> write_ulong(_ob_len1);
                    ::Genetic::LongSeq const * _ob_buf1 = _ob_buf0[_ob_i0].get_buffer();
                    for(::CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
                    {
                        ::CORBA::ULong _ob_len2 = _ob_buf1[_ob_i1].length();
                        _ob_out -> write_ulong(_ob_len2);
                        _ob_out -> write_long_array(_ob_buf1[_ob_i1].get_buffer(), _ob_len2);
                    }
                }
            }
            catch(const ::CORBA::SystemException& _ob_ex)
            {
                _OB_marshalEx(_ob_down, _ob_ex);
            }
            _OB_postMarshal(_ob_down);
            _OB_request(_ob_down);
            _OB_preUnmarshal(_ob_down);
            _OB_postUnmarshal(_ob_down);
            return;
        }
        catch(const OB::FailureException& _ob_ex)
        {
            _OB_handleFailureException(_ob_down, _ob_ex);
        }
    }
}

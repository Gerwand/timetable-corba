// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2005
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.3.3

#ifndef ___GeneticTT_h__
#define ___GeneticTT_h__


#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4030300L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace Genetic
{

class GeneticTimeTable;
typedef GeneticTimeTable* GeneticTimeTable_ptr;
typedef GeneticTimeTable* GeneticTimeTableRef;

extern OB::TypeCodeConst _tc_GeneticTimeTable;

} // End of namespace Genetic

void OBDuplicate(Genetic::GeneticTimeTable_ptr);
void OBRelease(Genetic::GeneticTimeTable_ptr);

void OBMarshal(Genetic::GeneticTimeTable_ptr, OB::OutputStreamImpl*);
void OBUnmarshal(Genetic::GeneticTimeTable_ptr&, OB::InputStreamImpl*);

namespace Genetic
{

typedef OB::ObjVar< GeneticTimeTable > GeneticTimeTable_var;
typedef OB::ObjOut< GeneticTimeTable > GeneticTimeTable_out;

} // End of namespace Genetic

namespace OBStubImpl_Genetic
{

class GeneticTimeTable;
typedef GeneticTimeTable* GeneticTimeTable_ptr;

} // End of namespace OBStubImpl_Genetic

void OBDuplicate(OBStubImpl_Genetic::GeneticTimeTable_ptr);
void OBRelease(OBStubImpl_Genetic::GeneticTimeTable_ptr);

namespace OBStubImpl_Genetic
{

typedef OB::ObjVar< GeneticTimeTable > GeneticTimeTable_var;

} // End of namespace OBStubImpl_Genetic

//
// IDL:Genetic:1.0
//
namespace Genetic
{

//
// IDL:Genetic/LongSeq:1.0
//
class OBUnique_LongSeq { };

typedef OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq > LongSeq;
typedef OB::SeqVar< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq > > LongSeq_var;
typedef OB::SeqOut< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq > > LongSeq_out;
extern OB::TypeCodeConst _tc_LongSeq;

struct OBInfo_LongSeq : public OB::ConstructedInfo
{
    OBInfo_LongSeq() { }

    virtual void free(void* p) const
    {
        delete (LongSeq*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new LongSeq(*(const LongSeq*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:Genetic/PeriodSeq:1.0
//
class OBUnique_PeriodSeq { };

typedef OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq > PeriodSeq;
typedef OB::SeqVar< OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq > > PeriodSeq_var;
typedef OB::SeqOut< OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq > > PeriodSeq_out;
extern OB::TypeCodeConst _tc_PeriodSeq;

struct OBInfo_PeriodSeq : public OB::ConstructedInfo
{
    OBInfo_PeriodSeq() { }

    virtual void free(void* p) const
    {
        delete (PeriodSeq*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new PeriodSeq(*(const PeriodSeq*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:Genetic/IndividualSeq:1.0
//
class OBUnique_IndividualSeq { };

typedef OB::VarSeq< OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq >, OBUnique_IndividualSeq > IndividualSeq;
typedef OB::SeqVar< OB::VarSeq< OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq >, OBUnique_IndividualSeq > > IndividualSeq_var;
typedef OB::SeqOut< OB::VarSeq< OB::VarSeq< OB::FixSeq< ::CORBA::Long, OBUnique_LongSeq >, OBUnique_PeriodSeq >, OBUnique_IndividualSeq > > IndividualSeq_out;
extern OB::TypeCodeConst _tc_IndividualSeq;

struct OBInfo_IndividualSeq : public OB::ConstructedInfo
{
    OBInfo_IndividualSeq() { }

    virtual void free(void* p) const
    {
        delete (IndividualSeq*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new IndividualSeq(*(const IndividualSeq*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:Genetic/Tuple:1.0
//
struct Tuple;
typedef OB::FixVar< Tuple > Tuple_var;
typedef Tuple& Tuple_out;

struct Tuple
{
    typedef Tuple_var _var_type;

    ::CORBA::Long tupleID;
    ::CORBA::Long classID;
    ::CORBA::Long teacherID;
    ::CORBA::Long roomID;

    void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(Tuple&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Tuple;

//
// IDL:Genetic/TupleSeq:1.0
//
class OBUnique_TupleSeq { };

typedef OB::FixSeq< Tuple, OBUnique_TupleSeq > TupleSeq;
typedef OB::SeqVar< OB::FixSeq< Tuple, OBUnique_TupleSeq > > TupleSeq_var;
typedef OB::SeqOut< OB::FixSeq< Tuple, OBUnique_TupleSeq > > TupleSeq_out;
extern OB::TypeCodeConst _tc_TupleSeq;

struct OBInfo_TupleSeq : public OB::ConstructedInfo
{
    OBInfo_TupleSeq() { }

    virtual void free(void* p) const
    {
        delete (TupleSeq*)p;
    }

    virtual void* dup(const void* p) const
    {
        return new TupleSeq(*(const TupleSeq*)p);
    }

    virtual void marshal(const void*, OB::OutputStreamImpl*) const;
    virtual void unmarshal(void*, OB::InputStreamImpl*) const;
};

//
// IDL:Genetic/GeneticTimeTable:1.0
//
class GeneticTimeTable : virtual public ::CORBA::Object
{
    GeneticTimeTable(const GeneticTimeTable&);
    void operator=(const GeneticTimeTable&);

protected:

    static const char* ids_[];

public:

    GeneticTimeTable() { }
    virtual ~GeneticTimeTable() { }

    typedef GeneticTimeTable_ptr _ptr_type;
    typedef GeneticTimeTable_var _var_type;

    static inline GeneticTimeTable_ptr
    _duplicate(GeneticTimeTable_ptr p)
    {
        if(p)
            p -> _add_ref();
        return p;
    }

    static inline GeneticTimeTable_ptr
    _nil()
    {
        return 0;
    }

    static GeneticTimeTable_ptr _narrow(::CORBA::Object_ptr);
    static GeneticTimeTable_ptr _unchecked_narrow(::CORBA::Object_ptr);

    static GeneticTimeTable_ptr _narrow(::CORBA::AbstractBase_ptr);
    static GeneticTimeTable_ptr _unchecked_narrow(::CORBA::AbstractBase_ptr);

    static const char** _OB_staticIds();

    //
    // IDL:Genetic/GeneticTimeTable/updateParameters:1.0
    //
    virtual void updateParameters(::CORBA::Long maxFitness,
                                  ::CORBA::Long periods,
                                  ::CORBA::Long naturalSelection) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
    //
    virtual IndividualSeq* getRandomPopulation(::CORBA::Long number,
                                               ::CORBA::Float_out meanFitness) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/mate:1.0
    //
    virtual IndividualSeq* mate(::CORBA::Long number,
                                ::CORBA::Float_out meanFitness,
                                ::CORBA::Long_out perfectPos) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/tuples:1.0
    //
    virtual TupleSeq* tuples() = 0;
    virtual void tuples(const TupleSeq&) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/population:1.0
    //
    virtual IndividualSeq* population() = 0;
    virtual void population(const IndividualSeq&) = 0;
};

} // End of namespace Genetic

//
// IDL:Genetic:1.0
//
namespace OBProxy_Genetic
{

//
// IDL:Genetic/GeneticTimeTable:1.0
//
class GeneticTimeTable : virtual public ::Genetic::GeneticTimeTable,
                         virtual public OBCORBA::Object
{
    GeneticTimeTable(const GeneticTimeTable&);
    void operator=(const GeneticTimeTable&);

protected:

    virtual OB::MarshalStubImpl_ptr _OB_createMarshalStubImpl();

public:

    GeneticTimeTable() { }
    virtual ~GeneticTimeTable() { }

    virtual const char** _OB_ids() const;

    //
    // IDL:Genetic/GeneticTimeTable/updateParameters:1.0
    //
    void updateParameters(::CORBA::Long maxFitness,
                          ::CORBA::Long periods,
                          ::CORBA::Long naturalSelection);

    //
    // IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
    //
    ::Genetic::IndividualSeq* getRandomPopulation(::CORBA::Long number,
                                                  ::CORBA::Float_out meanFitness);

    //
    // IDL:Genetic/GeneticTimeTable/mate:1.0
    //
    ::Genetic::IndividualSeq* mate(::CORBA::Long number,
                                   ::CORBA::Float_out meanFitness,
                                   ::CORBA::Long_out perfectPos);

    //
    // IDL:Genetic/GeneticTimeTable/tuples:1.0
    //
    ::Genetic::TupleSeq* tuples();
    void tuples(const ::Genetic::TupleSeq&);

    //
    // IDL:Genetic/GeneticTimeTable/population:1.0
    //
    ::Genetic::IndividualSeq* population();
    void population(const ::Genetic::IndividualSeq&);
};

} // End of namespace OBProxy_Genetic

//
// IDL:Genetic:1.0
//
namespace OBStubImpl_Genetic
{

//
// IDL:Genetic/GeneticTimeTable:1.0
//
class GeneticTimeTable : virtual public OB::StubImplBase
{
    GeneticTimeTable(const GeneticTimeTable&);
    void operator=(const GeneticTimeTable&);

protected:

    GeneticTimeTable() { }

public:

    static inline GeneticTimeTable_ptr
    _duplicate(GeneticTimeTable_ptr p)
    {
        if(p)
            p -> _OB_incRef();
        return p;
    }

    static inline GeneticTimeTable_ptr
    _nil()
    {
        return 0;
    }

    //
    // IDL:Genetic/GeneticTimeTable/updateParameters:1.0
    //
    virtual void updateParameters(::CORBA::Long maxFitness,
                                  ::CORBA::Long periods,
                                  ::CORBA::Long naturalSelection) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
    //
    virtual ::Genetic::IndividualSeq* getRandomPopulation(::CORBA::Long number,
                                                          ::CORBA::Float_out meanFitness) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/mate:1.0
    //
    virtual ::Genetic::IndividualSeq* mate(::CORBA::Long number,
                                           ::CORBA::Float_out meanFitness,
                                           ::CORBA::Long_out perfectPos) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/tuples:1.0
    //
    virtual ::Genetic::TupleSeq* tuples() = 0;
    virtual void tuples(const ::Genetic::TupleSeq&) = 0;

    //
    // IDL:Genetic/GeneticTimeTable/population:1.0
    //
    virtual ::Genetic::IndividualSeq* population() = 0;
    virtual void population(const ::Genetic::IndividualSeq&) = 0;
};

} // End of namespace OBStubImpl_Genetic

//
// IDL:Genetic:1.0
//
namespace OBMarshalStubImpl_Genetic
{

//
// IDL:Genetic/GeneticTimeTable:1.0
//
class GeneticTimeTable : 
    virtual public OBStubImpl_Genetic::GeneticTimeTable,
    virtual public OB::MarshalStubImpl
{
    GeneticTimeTable(const GeneticTimeTable&);
    void operator=(const GeneticTimeTable&);

protected:

    GeneticTimeTable() { }
    friend class OBProxy_Genetic::GeneticTimeTable;

public:

    //
    // IDL:Genetic/GeneticTimeTable/updateParameters:1.0
    //
    virtual void updateParameters(::CORBA::Long maxFitness,
                                  ::CORBA::Long periods,
                                  ::CORBA::Long naturalSelection);

    //
    // IDL:Genetic/GeneticTimeTable/getRandomPopulation:1.0
    //
    virtual ::Genetic::IndividualSeq* getRandomPopulation(::CORBA::Long number,
                                                          ::CORBA::Float_out meanFitness);

    //
    // IDL:Genetic/GeneticTimeTable/mate:1.0
    //
    virtual ::Genetic::IndividualSeq* mate(::CORBA::Long number,
                                           ::CORBA::Float_out meanFitness,
                                           ::CORBA::Long_out perfectPos);

    //
    // IDL:Genetic/GeneticTimeTable/tuples:1.0
    //
    virtual ::Genetic::TupleSeq* tuples();
    virtual void tuples(const ::Genetic::TupleSeq&);

    //
    // IDL:Genetic/GeneticTimeTable/population:1.0
    //
    virtual ::Genetic::IndividualSeq* population();
    virtual void population(const ::Genetic::IndividualSeq&);
};

} // End of namespace OBMarshalStubImpl_Genetic

//
// IDL:Genetic:1.0
//
namespace OBV_Genetic
{

} // End of namespace OBV_Genetic

//
// IDL:Genetic/LongSeq:1.0
//
void operator<<=(::CORBA::Any&, Genetic::LongSeq*);
void operator<<=(::CORBA::Any&, const Genetic::LongSeq&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const Genetic::LongSeq*&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::LongSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const Genetic::LongSeq& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const Genetic::LongSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Genetic/PeriodSeq:1.0
//
void operator<<=(::CORBA::Any&, Genetic::PeriodSeq*);
void operator<<=(::CORBA::Any&, const Genetic::PeriodSeq&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const Genetic::PeriodSeq*&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::PeriodSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const Genetic::PeriodSeq& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const Genetic::PeriodSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Genetic/IndividualSeq:1.0
//
void operator<<=(::CORBA::Any&, Genetic::IndividualSeq*);
void operator<<=(::CORBA::Any&, const Genetic::IndividualSeq&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const Genetic::IndividualSeq*&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::IndividualSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const Genetic::IndividualSeq& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const Genetic::IndividualSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Genetic/Tuple:1.0
//
void operator<<=(::CORBA::Any&, Genetic::Tuple*);
void operator<<=(::CORBA::Any&, const Genetic::Tuple&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const Genetic::Tuple*&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::Tuple* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const Genetic::Tuple& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const Genetic::Tuple*& val)
{
    return any.in() >>= val;
}

//
// IDL:Genetic/TupleSeq:1.0
//
void operator<<=(::CORBA::Any&, Genetic::TupleSeq*);
void operator<<=(::CORBA::Any&, const Genetic::TupleSeq&);
CORBA::Boolean operator>>=(const ::CORBA::Any&, const Genetic::TupleSeq*&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::TupleSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, const Genetic::TupleSeq& val)
{
    any.inout() <<= val;
}

inline ::CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, const Genetic::TupleSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Genetic/GeneticTimeTable:1.0
//
namespace CORBA
{

inline void
release(::Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _remove_ref();
}

inline Boolean
is_nil(::Genetic::GeneticTimeTable_ptr p)
{
    return p == 0;
}

inline void
release(OBStubImpl_Genetic::GeneticTimeTable_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(OBStubImpl_Genetic::GeneticTimeTable_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(::CORBA::Any&, Genetic::GeneticTimeTable_ptr*);
void operator<<=(::CORBA::Any&, Genetic::GeneticTimeTable_ptr);
CORBA::Boolean operator>>=(const ::CORBA::Any&, Genetic::GeneticTimeTable_ptr&);

inline void
operator<<=(::CORBA::Any_var& any, Genetic::GeneticTimeTable_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(::CORBA::Any_var& any, Genetic::GeneticTimeTable_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const ::CORBA::Any_var& any, Genetic::GeneticTimeTable_ptr& val)
{
    return any.in() >>= val;
}

#endif
